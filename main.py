# from urllib import request
from flask import *
import sqlite3
import pathlib
import secrets
from Flashcard import Flashcard
from item import *
from player import Player
from json import JSONDecoder

"""
RUN SERVER CODE 
---------------
With Flask installed do the following in a terminal:
$ export FLASK_APP=<your path to main.py>
$ flask run

Then in a browser, navigate to localhost:5000
"""

app = Flask(__name__, template_folder="templates")
# setup database for player authentication and retention of point values
database_path = pathlib.Path("database/players_db.db")
with sqlite3.connect(str(database_path)) as connection:
    cursor = connection.cursor()
    # instantiation: if the tables players don't exist, create them
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='players';")
    if not cursor.fetchone():
        print("creating new tables")
        cursor.execute(
            "CREATE TABLE players ("
            "username TEXT NOT NULL PRIMARY KEY, "
            "password TEXT NOT NULL, "
            "email TEXT NOT NULL, "
            "points INT DEFAULT 0);"
        )
        connection.commit()
        cursor.execute(
            "CREATE TABLE items ("
            "username VARCHAR(35) NOT NULL, "
            "item_name VARCHAR(50) NOT NULL, "
            "PRIMARY KEY (username, item_name), "
            "FOREIGN KEY (username) REFERENCES players(username) ON UPDATE CASCADE"
            ");"
        )
        connection.commit()
        cursor.execute(
            "CREATE TABLE flashcards ("
	        "username VARCHAR(35) NOT NULL, "
	        "term VARCHAR(50) NOT NULL, "
	        "definition TEXT NOT NULL, "
	        "set_name VARCHAR(50) NOT NULL, "
	        "PRIMARY KEY(username, term, definition, set_name), "
	        "FOREIGN KEY (username) REFERENCES players(username) ON UPDATE CASCADE"
            ");"
        )
        connection.commit()
    else:
        print("no new table creations")


with open("app_secret_key.txt", "r") as key:  # secret key (bytes) for the app: used for session management
    app.secret_key = key.readline().encode()
active_players = {}  # dictionary will hold K/V pairs of session IDs and their respective player


@app.route("/", methods=["GET"])
@app.route("/login", methods=["GET"])
def index():
    """
    Receives requests for directory root ("/") and /login and responds accordingly based on the request's cookie value (if present).
    :return: redirect to /dashboard if the request has a valid cookie, otherwise returns index.html (landing page)
    """
    # if player has an active cookie, take them to the dashboard
    if request.cookies.get("sessionid") in active_players:
        return redirect("/dashboard")
    return render_template("index.html")


@app.route("/dashboard", methods=["POST"])
def serve_dashboard():
    """
    Accepts POST form data generated by index.html and checks database to see if credentials from form match. If a match
    is found, the player is logged in and their corresponding Player object is inserted into the active_players dictionary.
    :return: dashboard.html + cookie if login successful, index.html with a login error if login unsuccessful
    """
    if request.method == "POST":
        # use name="<parameter>" in HTML forms to populate request.form dictionary with the right key/value pairs
        username, password = request.form["username"], request.form["password"]
        # would ideally sanitize input for any SQL injections here (if it were a serious concern)
        with sqlite3.connect(database_path) as login_conn:
            login_cursor = login_conn.cursor()
            # see if there is a matching username/password combo in the database
            login_cursor.execute(
                f"SELECT username, password FROM players WHERE username=? AND password=?;", (username, password))
            if not login_cursor.fetchone():
                return render_template("index.html", error="Invalid credentials")
            else:
                # authenticated: return a response with a sessionID set using secrets to get a random string
                # for extra assurance, could check to see if generated session ID is already in dict and redo if so
                # get the flashcard set names for the player (will use for GETs too)
                login_cursor.execute(f"SELECT DISTINCT set_name FROM flashcards WHERE username=? AND set_name IN (SELECT set_name FROM flashcards WHERE term != 'TERM');", (username,))
                flashcard_sets = [set_name[0] for set_name in login_cursor.fetchall()]
                login_cursor.execute(f"SELECT username, email, points FROM players WHERE username=?;", (username,))
                player_data = login_cursor.fetchone()
                login_response = make_response(
                    render_template("dashboard.html", username=player_data[0], points=player_data[2], flashcard_sets=flashcard_sets)
                )
                session_id = str(secrets.token_hex(16))
                login_response.set_cookie("sessionid", session_id)
                # update active_players dictionary to map the session ID to the player logging in
                active_players[session_id] = Player(*player_data)
                return login_response


@app.route("/logout", methods=["GET"])
def logout():
    """
    Authenticated players (whose requests have a cookie) are logged out, and their corresponding Player object in
    active_players gets removed.
    :return: index.html - request cookie
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    # logs a player out by deleting their session cookie and sending them back to index.html
    logout_response = make_response(render_template("index.html"))
    session_id = request.cookies.get("sessionid")
    player_username, player_points = active_players[session_id].username, active_players[session_id].points
    with sqlite3.connect(database_path) as logout_conn:
        logout_cursor = logout_conn.cursor()
        logout_cursor.execute(
            f"UPDATE players SET points=? WHERE username=?;", (player_points, player_username)
        )
        logout_conn.commit()
    # remove the player from the dictionary so that their session is dropped and login is required again
    active_players.pop(session_id)
    logout_response.delete_cookie("sessionid")
    return logout_response


@app.route("/profile", methods=["GET"])
def profile():
    """
    Brings players to the profile page, where they can edit their profile (Player) information and view their amount of points.
    :return: profile.html page
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    # show the player their profile info (username, password change option, email, points) and allow editing of all except points
    player_username = active_players[request.cookies.get("sessionid")].username
    # player_info = ()
    with sqlite3.connect(database_path) as profile_conn:
        profile_cursor = profile_conn.cursor()
        profile_cursor.execute(
            f"SELECT * FROM players WHERE username=?;", (player_username,)
        )
        player_info = profile_cursor.fetchone()
    player_password, player_email, player_points = player_info[1], player_info[2], player_info[3]
    return render_template("profile.html", username=player_username, email=player_email, points=player_points)


@app.route("/update_username", methods=["POST"])
def update_username():
    """
    Accepts JSON POST data generated by profile.html and updates the username for the player in active_players and the database.
    :return: blank response with 200 status code that responds back to profile.js
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    print(f"request data: {request.data.decode(encoding='utf-8')}")
    # check to see if data being updated is yay or nay
    player_username = active_players[request.cookies.get("sessionid")].username
    player_data = JSONDecoder().decode(s=request.data.decode(encoding="utf-8"))
    new_username = player_data["username"]
    with sqlite3.connect(database_path) as new_username_conn:
        new_username_cursor = new_username_conn.cursor()
        # below line ensures foreign key update cascading for flashcards and items
        new_username_cursor.execute("PRAGMA foreign_keys = ON;")
        new_username_cursor.execute("SELECT username FROM players WHERE username=?", (new_username,))
        if new_username_cursor.fetchone():
            return Response(status=400)  # new username already exists - return error code
        new_username_conn.commit()  # maybe
        print(f"foreign_keys: {new_username_cursor.execute('PRAGMA foreign_keys;').fetchone()}")
        new_username_cursor.execute(
            f"UPDATE players SET username=? WHERE username=?;", (new_username, player_username)
        )
        new_username_conn.commit()
    # key!!!: reflect the change in active_players as well
    active_players[request.cookies.get("sessionid")].username = new_username
    return Response(status=200)


@app.route("/update_password", methods=["POST"])
def update_password():
    """
    Accepts JSON POST data generated by profile.html and updates the password for the player in the database, first checking
    that the player's old password matches what is in the database.
    :return: blank response with 200 status code that responds back to profile.js if the old password is found, 400 status if not
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    player_username = active_players[request.cookies.get("sessionid")].username
    # check to see if old password is correct
    player_data = JSONDecoder().decode(s=request.data.decode(encoding="utf-8"))
    player_old_pass = player_data["oldPass"]
    player_new_pass = player_data["newPass"]
    with sqlite3.connect(database_path) as new_password_conn:
        new_password_cursor = new_password_conn.cursor()
        new_password_cursor.execute(
            f"SELECT password FROM players WHERE username=?;", (player_username,)
        )
        stored_pass = new_password_cursor.fetchone()[0]  # remember - tuple
        if stored_pass != player_old_pass:
            # print(f"stored_pass: {stored_pass}\nplayer_old_pass: {player_old_pass}\n")
            return Response(status=400)  # "bad request"
        else:
            new_password_cursor.execute(
                f"UPDATE players SET password=? WHERE username=?;", (player_new_pass, player_username)
            )
            new_password_conn.commit()
            return Response(status=200)


@app.route("/update_email", methods=["POST"])
def update_email():
    """
    Accepts JSON POST data generated by profile.html and updates the email for the player in active_players and the database.
    :return: blank response with 200 status code that responds back to profile.js
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    # check to see if data being updated is yay or nay
    player_username = active_players[request.cookies.get("sessionid")].username
    player_data = JSONDecoder().decode(s=request.data.decode(encoding="utf-8"))
    new_email = player_data["email"]
    with sqlite3.connect(database_path) as new_email_conn:
        new_email_cursor = new_email_conn.cursor()
        new_email_cursor.execute(
            f"UPDATE players SET email=? WHERE username=?;", (new_email, player_username)
        )
        new_email_conn.commit()
    # key!!!: reflect the change in active_players as well
    active_players[request.cookies.get("sessionid")].email = new_email
    return Response(status=200)


@app.route("/dashboard", methods=["GET"])
def dashboard():
    """
    Used when players navigate around the site and press "Go back" or "Back to dashboard" anywhere
    :return: dashboard.html
    """
    # if the request has a valid cookie, bring them to the dashboard, otherwise redirect to the welcome/login page
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    player_username = active_players[request.cookies.get("sessionid")].username
    player_points = active_players[request.cookies.get("sessionid")].points
    with sqlite3.connect(database_path) as dash_conn:
        dash_cursor = dash_conn.cursor()
        dash_cursor.execute(f"SELECT DISTINCT set_name FROM flashcards WHERE username=? AND set_name IN (SELECT set_name FROM flashcards WHERE term != 'TERM');", (player_username,))
        flashcard_sets = [set_name[0] for set_name in dash_cursor.fetchall()]
    return render_template("dashboard.html", username=player_username, points=player_points, flashcard_sets=flashcard_sets)


@app.route("/signup", methods=["GET"])
def signup():
    """
    Sends back the signup page for prospective players who want to make an account by clicking "create an account" on index.html.
    :return: signup.html
    """
    # return the signup form page
    return render_template("signup.html")


@app.route("/signup", methods=["POST"])
def create_new_user():
    """
    Accepts POST form data from signup.html that verifies input (username is unique and passwords match); if so, inserts
    new player values into database and inserts a Player object into active_players for the new user, and brings them to the dashboard.
    :return: dashboard.html if input is valid, signup.html + error if not
    """
    if request.method == "POST":
        username, email, password = request.form["username"], request.form["email"], request.form["passwordInit"]
        if password != request.form["passwordConf"]:  # ensure passwordInit matches passwordConf
            return render_template("signup.html", error="Passwords do not match")
        with sqlite3.connect(database_path) as create_connection:
            create_cursor = create_connection.cursor()
            # check to see if the username from the incoming form already exists, return error if so
            create_cursor.execute(f"SELECT username FROM players WHERE username=?;", (username,))
            if create_cursor.fetchone():
                return render_template("signup.html", error="Username already exists")
            else:
                # player doesn't exist yet and passwords match; insert new record
                create_cursor.execute(
                    f"INSERT INTO players (username, password, email) VALUES (?, ?, ?);", (username, password, email)
                )
                create_connection.commit()  # submit to the database
                # response won't need flashcards rendered since the new player will not have any
                creation_response = make_response(render_template("dashboard.html", username=username, points=0))
                session_id = str(secrets.token_hex(16))
                creation_response.set_cookie("sessionid", session_id)  # set authentication cookie
                active_players[session_id] = Player(username, email)  # default point value of 0
                # return render_template("dashboard.html") 
                return creation_response  # what was originally supposed to be there


@app.route("/create_new_set", methods=["POST"])
def create_new_set():
    """
    Creates a new set named by set_name and inserts initial record into database with filler term and definition values.
    :return: redirect to /flashcard_set to display the list of all flashcard sets
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    session_id = request.cookies.get("sessionid")
    player_username = active_players[session_id].username
    set_data = JSONDecoder().decode(s=request.data.decode(encoding="utf-8"))
    set_name = set_data["set_name"]
    # create a filler record in DB to denote creation of an empty flashcard set
    with sqlite3.connect(database_path) as new_set_conn:
        new_set_cursor = new_set_conn.cursor()
        new_set_cursor.execute(
            f"SELECT * FROM flashcards WHERE username=? AND set_name=?", (player_username, set_name)
        )
        if new_set_cursor.fetchone():
            return Response(status=400)
        new_set_cursor.execute(
            f"INSERT INTO flashcards(username, term, definition, set_name) VALUES(?, 'TERM', 'DEF', ?);", (player_username, set_name)
        )
        new_set_conn.commit()
    return redirect("/flashcard_set")


@app.route("/flashcard", methods=["GET"])
def new_flashcard():
    """
    Brings the player to the flashcard creation page where they can create a new flashcard and insert it into a set of their choice.
    :return: flashcard.html with a list of the player's different flashcard sets
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    player_username = active_players[request.cookies.get("sessionid")].username
    flashcard_sets = []
    with sqlite3.connect(database_path) as list_sets_conn:
        list_sets_cursor = list_sets_conn.cursor()
        list_sets_cursor.execute(
            f"SELECT DISTINCT set_name FROM flashcards WHERE username=?;", (player_username,)
        )
        for entry in list_sets_cursor.fetchall():
            flashcard_sets.append(entry[0])  # indexed b/c this execute() statement returns a list of size 1 tuples
    current_set = request.args.get("current_set")
    return render_template("flashcard.html", flashcard_sets=flashcard_sets, current_set=current_set)

@app.route("/create_flashcard", methods=["POST"])
def create_flashcard():
    """
    Accepts JSON POST data for a newly created flashcard and inserts it into the database, tying it to the specified set.
    :return: 200 response status to respond back to flashcard.js
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    session_id = request.cookies.get("sessionid")
    player_username = active_players[session_id].username
    flashcard_data = JSONDecoder().decode(s=request.data.decode(encoding="utf-8"))
    term, definition, set_name = flashcard_data["term"], flashcard_data["definition"], flashcard_data["set_name"]
    # only thing to add here will be persistence of flashcards and sets for individual players in the database - done below:
    with sqlite3.connect(database_path) as fc_conn:
        fc_cursor = fc_conn.cursor()
        fc_cursor.execute(
            f"INSERT INTO flashcards(username, term, definition, set_name) VALUES (?, ?, ?, ?);", (player_username, term, definition, set_name)
        )
        fc_conn.commit()
    return Response(status=200)

# does not change to new term
@app.route("/edit_flashcard", methods=["GET"])
def edit_flashcard():
    """
    Brings player to the edit page, where they can edit the term and definition for a given flashcard.
    :return: edit_flashcard.html with present values for the flashcard + the set it belongs to
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    player_username = active_players[request.cookies.get("sessionid")].username
    set_name = request.args.get('card_set')
    edit_term = request.args.get('term')
    with sqlite3.connect(database_path) as edit_conn:
        edit_cursor = edit_conn.cursor()
        edit_cursor.execute(
            f"SELECT term, definition FROM flashcards WHERE username=? AND set_name=?;", (player_username, set_name)
        )
        fc_data = edit_cursor.fetchall()
        fc_set = [Flashcard(fc[0], fc[1]) for fc in fc_data]
    for card in fc_set:
        if card.term == edit_term:
            flashcard_to_edit = card
            break
    return render_template('edit_flashcard.html', set_name=set_name, flashcard=flashcard_to_edit)

@app.route("/update_flashcard", methods=["POST"])
def update_flashcard():
    """
    Accepts POST form data for updates to a flashcard, updating the database values where the flashcard sits.
    :return: redirects to the flashcard's individual set page to show the reflected change
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    
    session_id = request.cookies.get("sessionid")
    player_username = active_players[session_id].username
    edit_term = request.form["old_term"]
    new_term = request.form["term"]
    new_definition = request.form["definition"]
    set_name = request.form["card_set"]

    with sqlite3.connect(database_path) as update_conn:
        update_cursor = update_conn.cursor()
        update_cursor.execute(
            f"UPDATE flashcards SET term=?, definition=? WHERE username=? AND term=? AND set_name=?",
            (new_term, new_definition, player_username, edit_term, set_name)
        )
        update_conn.commit()

    redirect_url = f"/individual_set?card_set={set_name}"
    return redirect(redirect_url)

@app.route("/delete_flashcard", methods=["GET"])
def delete_flashcard():
    """
    Takes the GET request arguments (flashcard term and set name) and removes the flashcard from the database specified by them.
    :return:
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    
    session_id = request.cookies.get("sessionid")
    player_username = active_players[session_id].username
    set_name = request.args.get("card_set")
    delete_term = request.args.get("term")

    with sqlite3.connect(database_path) as delete_conn:
        delete_cursor = delete_conn.cursor()
        delete_cursor.execute(
            "DELETE FROM flashcards WHERE username=? AND term=? AND set_name=?",
            (player_username, delete_term, set_name)
        )
        delete_conn.commit()
    return redirect("/individual_set?card_set=" + set_name)

@app.route("/individual_set", methods=["GET"])
def single_set_page():
    """
    Shows the player all the flashcards in the set specified by the GET request argument (card_set).
    :return: single_set.html with the name of the flashcard set, its flashcards, and names of all the other flashcard sets
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    set_name = request.args.get("card_set")
    player_username = active_players[request.cookies.get("sessionid")].username
    flashcards, flashcard_sets = [], []
    with sqlite3.connect(database_path) as list_flashcards_conn:
        list_flashcards_cursor = list_flashcards_conn.cursor()
        list_flashcards_cursor.execute(
            f"SELECT term, definition, set_name FROM flashcards WHERE username=?;", (player_username,)
        )
        for entry in list_flashcards_cursor.fetchall():
            # append Flashcard objects into flashcards with retrieved term & definition where set_name matches the set name for the term/def
            if entry[2] == set_name:
                flashcards.append(Flashcard(entry[0], entry[1]))
            # if the set name is not already in the list of all flashcard sets, append it
            elif entry[2] not in flashcard_sets:
                flashcard_sets.append(entry[2])
        # drop the filler entry from the specified flashcard set
        for fc in flashcards:
            if fc.term == "TERM" and fc.definition == "DEF":
                flashcards.remove(fc)
        # remove the current set name from flashcard_sets to reduce redundancy - NOT NEEDED WITH ELIF
        # flashcard_sets.remove(set_name)
    return render_template("single_set.html", current_set=set_name,flashcards=flashcards, flashcard_sets=flashcard_sets)


@app.route("/flashcard_set", methods=["GET"])
def flashcard_set():
    """
    Essentially the landing page for flashcards; shows players the different flashcard sets that they have and gives them
    the option to create a new flashcard (via a link in flashcardset.html) or to create a new flashcard set.
    :return: flashcardset.html with flashcard sets that the player has, if any
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    player_username = active_players[request.cookies.get("sessionid")].username
    flashcard_sets = []
    with sqlite3.connect(database_path) as list_sets_conn:
        list_sets_cursor = list_sets_conn.cursor()
        list_sets_cursor.execute(
            f"SELECT DISTINCT set_name FROM flashcards WHERE username=?;", (player_username,)
        )
        for entry in list_sets_cursor.fetchall():
            flashcard_sets.append(entry[0])
    return render_template("flashcardset.html", flashcard_sets=flashcard_sets)

@app.route("/delete_set", methods=["GET"])
def delete_set():
    """
    Takes the GET request (card_set) and deletes the flashcard set and its flashcards from the database.
    :return: redirects to flashcard_set to show the change
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    session_id = request.cookies.get("sessionid")
    player_username = active_players[session_id].username
    set_name = request.args.get('card_set')
    # delete the flashcard set and its flashcards from the database
    with sqlite3.connect(database_path) as delete_set_conn:
        delete_set_cursor = delete_set_conn.cursor()
        delete_set_cursor.execute(
            "DELETE FROM  flashcards WHERE username=? AND set_name=?",
            (player_username, set_name)
        )
        delete_set_conn.commit()
    return redirect('/flashcard_set')

# type "/study" at end of URL to get to study page
@app.route("/study", methods=["GET"])
def study():
    """
    Brings players into study mode, where they answer MC questions generated by a chosen flashcard set.
    :return: study.html with a set of flashcards ("questions")
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    player_username = active_players[request.cookies.get("sessionid")].username
    flashcard_set = request.args.get("flashcard_set")
    with sqlite3.connect(database_path) as study_conn:
        study_cursor = study_conn.cursor()
        study_cursor.execute(
            f"SELECT term, definition FROM flashcards WHERE username=? AND set_name=?;", (player_username, flashcard_set)
        )
        study_data = study_cursor.fetchall()  # list of tuples
        questions = [Flashcard(*term_and_def) for term_and_def in study_data]
        # get rid of TERM and DEF filler flashcard
        for q in questions:
            if q.term == "TERM" and q.definition == "DEF":
                questions.remove(q)
    questions_json = [flashcard.__dict__ for flashcard in questions]
    return render_template('study.html', questions=questions_json)

@app.route("/shop", methods=["GET"])
def shop():
    """
    Brings players to the item shop, where they can buy items and have them added to their inventory which they can use
    to help them in testing mode.
    :return: shop.html + viable shop items + the player's points + the player's current inventory
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    # to identify the specific player and get their current points
    session_id = request.cookies.get("sessionid")
    player_username, player_points = active_players[session_id].username, active_players[session_id].points
    shop_items = all_items()  # from item module
    # retrieve from the DB what the player has in their inventory
    player_inventory = []
    with sqlite3.connect(database_path) as shop_conn:
        shop_cursor = shop_conn.cursor()
        shop_cursor.execute(
            f"SELECT item_name FROM items WHERE username=?;", (player_username,)
        )
        player_items = shop_cursor.fetchall()
        if player_items is not None:
            # for whatever item names a player has in the database, load the actual item object into their inventory
            for item_name in player_items:
                for item_object in shop_items:
                    if item_object.name == item_name[0]:  # indexed because item_name is a tuple
                        player_inventory.append(item_object)
    shop_items_json = [item.__dict__ for item in shop_items]
    player_inventory_json = [item.__dict__ for item in player_inventory]
    return render_template("shop.html", shop_items_json=shop_items_json, player_points=player_points, player_inventory_json=player_inventory_json)



@app.route("/update_points", methods=["POST"])
def update_points():
    """
    Receives point data from TestingModeScene.js and updates player's points in active_players{} and the DB accordingly.
    :return: 200 status code back to TestingModeScene.js upon receipt of request
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    session_id = request.cookies.get("sessionid")
    player_username = active_players[session_id].username
    point_data = JSONDecoder().decode(s=request.data.decode(encoding="utf-8"))
    points_to_add = point_data["earned_points"]
    # update player's points in active_players{}, then use active_players{} to update DB
    active_players[session_id].points += points_to_add
    with sqlite3.connect(database_path) as points_conn:
        points_cursor = points_conn.cursor()
        points_cursor.execute("UPDATE players SET points=? WHERE username=?", (active_players[session_id].points, player_username))
        points_conn.commit()
    return Response(status=200)


@app.route("/testing_mode", methods=["GET"])
def testing_mode():
    """
    Brings players into testing mode, where they earn points by answering fill-in-the-blank style questions for their
    chosen flashcard set.
    :return: testing_mode.html + a set of flashcards
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    player_username = active_players[request.cookies.get("sessionid")].username
    flashcard_set = request.args.get("flashcard_set")
    # then do something with flashcard_set for a query
    questions = []
    with sqlite3.connect(database_path) as test_conn:
        test_cursor = test_conn.cursor()
        test_cursor.execute(
            f"SELECT term, definition FROM flashcards WHERE username=? AND set_name=?", (player_username, flashcard_set)
        )
        questions = [Flashcard(fc[0], fc[1]) for fc in test_cursor.fetchall()]
        for q in questions:
            if q.term == "TERM" and q.definition == "DEF":
                questions.remove(q)
        questions_json = [flashcard.__dict__ for flashcard in questions]
    return render_template("testing_mode.html", questions=questions_json)


@app.route("/buy_item", methods=["POST"])
def buy_item():
    """
    Accepts JSON POST data to handle purchases that a player makes in the item shop, adding the item to their inventory and deducting from
    their points the cost of the purchased item.
    :return: response with 200 status code to respond back to shop.js
    """
    if not request.cookies.get("sessionid") in active_players:
        return redirect("/")
    session_id = request.cookies.get("sessionid")
    player_username = active_players[session_id].username
    item_data = JSONDecoder().decode(s=request.data.decode(encoding="utf-8"))
    item_name, item_cost = item_data["itemName"], int(item_data["itemCost"])  # finally into a string and integer
    # insert item into database for the purchasing player
    with sqlite3.connect(database_path) as buy_conn:
        buy_cursor = buy_conn.cursor()
        buy_cursor.execute(
            f"INSERT INTO items(username, item_name) VALUES (?, ?);", (player_username, item_name)
        )
        buy_conn.commit()
        # deduct cost of item from Player's points in active_players{}
        active_players[session_id].points -= item_cost  # note: only gets logged when user logs out
        buy_cursor.execute(
            f"UPDATE players SET points=? WHERE username=?;", (active_players[session_id].points, player_username)
        )
        buy_conn.commit()
    return Response(status=200)  # temporary confirmation for the JavaScript portion


if __name__ == '__main__':
    app.run()